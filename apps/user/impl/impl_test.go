package impl_test

import (
	"context"
	"os"
	"regexp"
	"testing"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/acd19ml/TalentRank/apps/git"
	"github.com/acd19ml/TalentRank/apps/llm"
	"github.com/acd19ml/TalentRank/apps/user"
	"github.com/acd19ml/TalentRank/apps/user/impl"
	"github.com/stretchr/testify/require"
	"google.golang.org/grpc"
)

func TestInferUserLocationWithLLM_Integration(t *testing.T) {
	if os.Getenv("ARK_API_KEY") == "" {
		t.Fatal("ARK_API_KEY is not set")
	}
	conn, err := grpc.Dial("localhost:50052", grpc.WithInsecure())
	require.NoError(t, err)
	defer conn.Close()

	client := llm.NewLLMServiceClient(conn)
	s := &impl.ServiceImpl{}
	s.SetLLMClient(client) // 使用 setter 方法注入 llm 客户端

	userIns := &user.User{Username: "Away0x"}
	err = s.InferUserLocationWithLLM(context.Background(), userIns)

	require.NoError(t, err)
	require.NotEmpty(t, userIns.PossibleNation)
	require.NotEmpty(t, userIns.ConfidenceLevel)
}

func TestConstructUser_Integration(t *testing.T) {
	if os.Getenv("GITHUB_TOKEN") == "" {
		t.Fatal("GITHUB_TOKEN is not set")
	}
	// 设置 gRPC 连接，确保在本地启动 gRPC 服务（例如 localhost:50051）
	conn, err := grpc.Dial("localhost:50051", grpc.WithInsecure())
	require.NoError(t, err)
	defer conn.Close()

	// 初始化 GitServiceClient
	client := git.NewGitServiceClient(conn)
	service := &impl.ServiceImpl{}
	service.SetGitClient(client)

	// 准备上下文和输入参数
	ctx := context.Background()
	username := "Away0x"

	// 调用待测试的函数
	userObj, err := service.ConstructUser(ctx, username)

	// 确认没有错误发生
	require.NoError(t, err)
	require.NotNil(t, userObj)

	// 验证各个字段是否正确填充
	require.Equal(t, username, userObj.Username)

	// 检查默认 ID 是否被填充
	require.NotEmpty(t, userObj.Id, "User ID should be generated by InjectDefault")

	// 清理：测试结束后断开连接
	t.Log("Integration test for constructUser completed successfully.")
}

func TestGetOrganizations_Integration(t *testing.T) {
	token := os.Getenv("GITHUB_TOKEN")
	if token == "" {
		t.Fatal("GITHUB_TOKEN is not set")
	}

	// 设置 gRPC 连接，连接到本地 gRPC 服务
	conn, err := grpc.Dial("localhost:50051", grpc.WithInsecure())
	require.NoError(t, err)
	defer conn.Close()

	// 创建 GitServiceClient 实例
	client := git.NewGitServiceClient(conn)
	service := &impl.ServiceImpl{}
	service.SetGitClient(client)

	// 准备请求参数
	ctx := context.Background()
	req := &git.GetUsernameRequest{Username: "donghwan-shin"} // 使用有效的 GitHub 用户名

	// 调用待测试的 GetOrganizations 方法
	resp, err := client.GetOrganizations(ctx, req)
	require.NoError(t, err)
	require.NotNil(t, resp)

	// 验证响应中的组织列表
	require.NotEmpty(t, resp.Organizations, "Organizations list should not be empty")
	for _, org := range resp.Organizations {
		t.Logf("Organization: %s", org)
	}
}

func TestCompareAndUpdateUserRepos(t *testing.T) {
	// 1. Mock 数据库连接
	db, mock, err := sqlmock.New()
	if err != nil {
		t.Fatalf("Failed to create mock database connection: %v", err)
	}
	defer db.Close()

	// 2. 设置 ServiceImpl 和所需的 DB 连接
	service := &impl.ServiceImpl{Db: db}

	// 模拟从数据库中获取用户数据
	mock.ExpectQuery(regexp.QuoteMeta("SELECT * FROM user WHERE username = ?")).
		WithArgs("user1").
		WillReturnRows(sqlmock.NewRows([]string{"id", "username", "name", "company", "blog", "location", "email", "bio", "followers", "organizations", "readme", "commits", "score", "possibleNation", "confidenceLevel"}).
			AddRow("1", "user1", "User One", "Company A", "user1.blog", "Location A", "user1@example.com", "Bio text", 100, `["org1","org2"]`, "README text", 10, 50, "PossibleNation", "ConfidenceLevel"))

	// 模拟从数据库获取用户仓库数据
	mock.ExpectQuery(regexp.QuoteMeta("SELECT * FROM repo WHERE user_id = ?")).
		WithArgs("1").
		WillReturnRows(sqlmock.NewRows([]string{
			"id", "user_id", "repo", "star", "fork", "dependent", "commits", "commits_total",
			"issue", "issue_total", "pull_request", "pull_request_total",
			"code_review", "code_review_total", "line_change", "line_change_total"}).
			AddRow("1", "1", "repo1", 10, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0))

	// 模拟数据库事务的开始
	mock.ExpectBegin()                                        // Add expectation for Begin call
	mock.ExpectPrepare(regexp.QuoteMeta("INSERT INTO User")). // Expect Prepare statement for the INSERT INTO User query
									ExpectExec().
									WithArgs("1", "user1", "User One", "Company A", "user1.blog", "Location A", "user1@example.com", "Bio text", 100, `["org1","org2"]`, "README text", 10, 50, "PossibleNation", "ConfidenceLevel").
									WillReturnResult(sqlmock.NewResult(1, 1)) // Mock the execution of the INSERT statement

	mock.ExpectCommit() // Expect Commit after the insert operation

	// 假设有新数据
	newRepos := &user.UserRepos{
		User: &user.User{
			Username: "user1",
			Name:     "User One",
		},
		Repos: []*user.Repo{
			{Repo: "repo1", Star: 10, Fork: 5},
		},
	}

	// 调用方法
	err = service.CompareAndUpdateUserRepos(context.Background(), newRepos)
	if err != nil {
		t.Fatalf("Failed to compare and update repos: %v", err)
	}

	// 验证预期的数据库查询是否已发生
	if err := mock.ExpectationsWereMet(); err != nil {
		t.Fatalf("There were unmet expectations: %v", err)
	}
}
